import { ops1, scalar, hasop } from './core';
import complex, { complexT } from './complex';
import rational, { rationalB, canMakeRationalOps } from './rational';
export { partialFractionsT, partialPower, hermiteReduce, squareFreeFactorization, factorOverK, rothsteinPartial, rothsteinResidues, resultant, sylvesterMatrix, evaluateMod } from './factors';
export type coeffOps<T, S = any> = ops1<T, S> & (hasop<'mag'> | hasop<'sign'>);
export type PolyNTypes = number | coeffOps<any>;
export type PolyTypes = PolyNTypes | bigint;
type normalized<T> = T extends bigint ? rationalB : T;
type realRoots<T> = T extends number ? number[] : T extends bigint ? rationalB[] : T extends scalar<any> ? T[] : never;
type complexRoots<T> = T extends number ? complex[] : T extends (scalar<T> & hasop<'sqrt' | 'rpow'>) ? complexT<T>[] : never;
type rationalRoots<T> = T extends number ? rational[] : T extends bigint ? rationalB[] : T extends rational ? rational[] : T extends rationalB ? rationalB[] : T extends canMakeRationalOps<any> ? rationalB[] : never;
export interface PolynomialN<C> {
    c: C[];
    is<U extends PolyTypes>(g: (x: any) => x is U): this is PolynomialN<U>;
    degree(): number;
    dup(): PolynomialN<C>;
    evaluate(t: C): C;
    evaluate(t: C[]): C[];
    deriv(): Polynomial<C>;
    mul(b: PolynomialN<C>): PolynomialN<C>;
    divmod(b: PolynomialN<C>): Polynomial<C>;
    rationalRoots(): rationalRoots<C>;
    realRoots(epsilon?: number): realRoots<C>;
    allRoots(epsilon?: number): complexRoots<C>;
    refine_roots(x: realRoots<C>, count?: number): realRoots<C>;
    toString(x?: string, debug?: boolean): string;
}
export interface Polynomial<C> extends PolynomialN<C> {
    is<U extends PolyTypes>(g: (x: any) => x is U): this is Polynomial<U>;
    leadCoeff(): C;
    from(x: C | number | bigint): Polynomial<C>;
    dup(): Polynomial<C>;
    neg(): Polynomial<C>;
    abs(): Polynomial<C>;
    add(b: C | Polynomial<C>): Polynomial<C>;
    sub(b: C | Polynomial<C>): Polynomial<C>;
    scale(b: C | number): Polynomial<C>;
    rscale(b: C): Polynomial<C>;
    mul(b: Polynomial<C>): Polynomial<C>;
    divmod(b: Polynomial<C>): Polynomial<C>;
    div(b: Polynomial<C>): Polynomial<C>;
    ipow(b: number): Polynomial<C>;
    sign(): number;
    compare(b: Polynomial<C>): number;
    eq(b: Polynomial<C>): boolean;
    lt(b: Polynomial<C>): boolean;
    selfAdd(b: C | Polynomial<C>): void;
    selfSub(b: C | Polynomial<C>): void;
    selfScale(b: C): void;
    selfRscale(b: C): void;
    pseudoRemainder(b: Polynomial<C>): void;
    content(): C | undefined;
    shift(n: number): Polynomial<C>;
    normalise(epsilon?: number): PolynomialN<normalized<C>>;
    map<U extends PolyTypes>(func: (c: C, i: number) => U): Polynomial<U>;
    toString(x?: string, debug?: boolean): string;
}
export declare function PolynomialN(c: readonly number[]): PolynomialN<number>;
export declare function PolynomialN<T extends coeffOps<T>>(c: T[]): PolynomialN<T>;
export declare function Polynomial(c: readonly number[]): Polynomial<number>;
export declare function Polynomial(c: readonly bigint[]): Polynomial<bigint>;
export declare function Polynomial<T extends coeffOps<T, any>>(c: T[]): Polynomial<T>;
export declare function Polynomial<T extends PolyTypes>(c: T[]): Polynomial<T>;
export declare function multiplicityAt<T extends number | scalar<any>>(poly: Polynomial<T> | PolynomialN<T>, x: T, epsilon?: number): number;
export declare function legendrePolynomial(n: number): Polynomial<number>;
export declare function legendreTable(n: number): [number, number][];
