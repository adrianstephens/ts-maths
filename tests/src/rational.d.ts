import { Operators, ops1, hasop, divmodto } from "./core";
import { FractionOptions } from "./string";
export type rationalOps<T extends ops1<T>> = ops1<T> & hasop<'from' | 'lt' | 'sign' | 'abs' | 'ipow'> & divmodto<T>;
export type canMakeRationalOps<T extends ops1<T>> = ops1<T> & hasop<'from' | 'divmod' | 'recip' | 'lt'>;
export type canMakeRational = number | bigint | canMakeRationalOps<any>;
export declare function canMakeRational(x: ops1<any>): x is canMakeRationalOps<any>;
declare class _rational {
    num: number;
    den: number;
    constructor(num: number, den?: number);
    from(n: canMakeRational): rational;
    dup(): rational;
    neg(): rational;
    recip(): rational;
    abs(): rational;
    frac(): rational;
    floor(): number;
    sign(): number;
    set(b: rational): rational;
    scale(b: number): rational;
    mul(b: rational): rational;
    add(b: rational): rational;
    sub(b: rational): rational;
    div(b: rational): rational;
    mod(b: rational): rational;
    ipow(b: number): rational;
    divmod(b: rational): number;
    compare(b: rational): number;
    lt(b: rational): boolean;
    eq(b: rational): boolean;
    isInteger(): boolean;
    is0(): boolean;
    is1(): boolean;
    toString(opts?: FractionOptions): string;
    valueOf(): number;
}
export declare const rational: ((num: number, den?: number) => rational) & Omit<Operators<rational>, 'from'> & {
    zero(): rational;
    from(n: canMakeRational, maxDen?: number): rational;
    fromContinuedFraction(terms: number[], maxDen?: number): rational;
};
export type rational = _rational;
export default rational;
declare class _rationalB {
    num: bigint;
    den: bigint;
    constructor(num: bigint, den?: bigint);
    from(n: canMakeRational): rationalB;
    dup(): rationalB;
    neg(): rationalB;
    recip(): rationalB;
    abs(): rationalB;
    frac(): rationalB;
    floor(): bigint;
    sign(): number;
    set(b: rationalB): rationalB;
    scale(b: number | bigint): rationalB;
    mul(b: rationalB): rationalB;
    add(b: rationalB): rationalB;
    sub(b: rationalB): rationalB;
    div(b: rationalB): rationalB;
    mod(b: rationalB): rationalB;
    ipow(b: number): rationalB;
    divmod(b: rationalB): bigint;
    compare(b: rationalB): number;
    lt(b: rationalB): boolean;
    eq(b: rationalB): boolean;
    toString(): string;
    valueOf(): number;
}
export declare const rationalB: ((num: bigint, den?: bigint) => rationalB) & Omit<Operators<rationalB>, 'from'> & {
    from(n: canMakeRational, maxDen?: bigint): rationalB;
    fromContinuedFraction(terms: (bigint | number)[], maxDen?: bigint): rationalB;
};
export type rationalB = _rationalB;
declare class _rationalT<T extends rationalOps<T>> {
    num: T;
    den: T;
    constructor(num: T, den: T);
    from(n: number | bigint | T | rational | rationalB, maxDen?: bigint): rationalT<T>;
    dup(): rationalT<T>;
    neg(): rationalT<T>;
    recip(): rationalT<T>;
    abs(): rationalT<T>;
    frac(): rationalT<T>;
    floor(): any;
    sign(): number;
    set(b: rationalT<T>): this;
    scale(b: number): rationalT<T>;
    mul(b: rationalT<T>): rationalT<T>;
    add(b: rationalT<T>): rationalT<T>;
    sub(b: rationalT<T>): rationalT<T>;
    div(b: rationalT<T>): rationalT<T>;
    mod(b: rationalT<T>): rationalT<T>;
    ipow(b: number): rationalT<T>;
    divmod(b: rationalT<T>): any;
    compare(b: rationalT<T>): number;
    lt(b: rationalT<T>): boolean;
    eq(b: rationalT<T>): boolean;
    toString(): string;
    valueOf(): Object;
}
export declare const rationalT: <T extends rationalOps<T>>(num: T, den: T) => _rationalT<T>;
export type rationalT<T extends rationalOps<T>> = _rationalT<T>;
